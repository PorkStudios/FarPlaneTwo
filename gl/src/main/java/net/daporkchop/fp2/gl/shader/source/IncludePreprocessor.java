/*
 * Adapted from The MIT License (MIT)
 *
 * Copyright (c) 2020-2024 DaPorkchop_
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
 * is furnished to do so, subject to the following conditions:
 *
 * Any persons and/or organizations using this software must include the above copyright notice and this permission notice,
 * provide sufficient credit to the original authors of the project (IE: DaPorkchop_), as well as provide a link to the original project.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

package net.daporkchop.fp2.gl.shader.source;

import lombok.RequiredArgsConstructor;
import net.daporkchop.fp2.api.util.Identifier;
import net.daporkchop.fp2.common.util.ResourceProvider;
import net.daporkchop.fp2.common.util.exception.ResourceNotFoundException;
import net.daporkchop.fp2.gl.GLExtension;
import net.daporkchop.fp2.gl.OpenGL;

import java.io.BufferedReader;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Collections;
import java.util.IdentityHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static net.daporkchop.lib.common.util.PValidation.*;

/**
 * Processes {@code #include} directives in a GLSL source file.
 *
 * @author DaPorkchop_
 */
@RequiredArgsConstructor
public final class IncludePreprocessor {
    private static final Pattern INCLUDE_PATTERN = Pattern.compile("^#include <\"([^\"]+)\">");

    private final ResourceProvider resourceProvider;

    private final List<SourceLine> lines = new ArrayList<>();
    private final Set<Identifier> includedFiles = Collections.newSetFromMap(new IdentityHashMap<>());

    /**
     * Adds the version string for the current OpenGL context to the beginning of the shader source code.
     *
     * @param gl the OpenGL context
     */
    public IncludePreprocessor addVersionHeader(OpenGL gl) {
        checkState(this.lines.isEmpty(), "version header must be at top of shader source");

        Identifier id = Identifier.fromLenient("opengl", "<auto-generated>");
        this.lines.add(new SourceLine("#version " + gl.version().glsl(), id, -1, null));
        for (GLExtension extension : gl.extensions()) {
            if (extension.glsl()) {
                this.lines.add(new SourceLine("#extension " + extension.name() + " : require", id, -1, null));
            }
        }
        return this;
    }

    /**
     * Defines the given preprocessor macros.
     *
     * @param defines the names and values of the preprocessor macros to define
     */
    public IncludePreprocessor define(Map<String, ?> defines) {
        checkState(!this.lines.isEmpty(), "version header must be at top of shader source");

        Identifier id = Identifier.fromLenient("opengl", "<auto-generated>");
        for (Map.Entry<String, ?> entry : defines.entrySet()) {
            Object rawValue = entry.getValue();
            String value;
            if (rawValue instanceof Boolean) {
                value = ((boolean) rawValue) ? "1" : "0";
            } else {
                value = String.valueOf(rawValue);
            }

            this.lines.add(new SourceLine("#define " + entry.getKey() + ' ' + value, id, -1, null));
        }
        return this;
    }

    /**
     * Includes the source lines from the file with the given {@link Identifier}.
     *
     * @param file the {@link Identifier} of the source file to be included
     */
    public IncludePreprocessor include(Identifier file) throws IOException, ResourceNotFoundException {
        return this.include(file, null);
    }

    private IncludePreprocessor include(Identifier file, SourceLine includedFrom) throws IOException, ResourceNotFoundException {
        if (!this.includedFiles.add(file)) { //this source file has already been included!
            return this;
        }

        int lineNo = 1;
        try (BufferedReader reader = new BufferedReader(this.resourceProvider.provideResourceAsReader(file, StandardCharsets.UTF_8))) {
            for (String line; (line = reader.readLine()) != null; lineNo++) {
                SourceLine sourceLine = new SourceLine(line, file, lineNo, includedFrom);
                if (line.startsWith("#include ")) {
                    Matcher matcher = INCLUDE_PATTERN.matcher(line);
                    checkArg(matcher.find(), sourceLine);
                    this.include(Identifier.from(matcher.group(1)), sourceLine);
                } else {
                    this.lines.add(sourceLine);
                }
            }
        }
        return this;
    }

    /**
     * @return the combined source lines
     */
    public List<SourceLine> finish() {
        return new ArrayList<>(this.lines);
    }
}
